diff --git a/content/renderer/media/stream/webmediaplayer_ms_unittest.cc b/content/renderer/media/stream/webmediaplayer_ms_unittest.cc
index bf66efe..00933375 100644
--- a/content/renderer/media/stream/webmediaplayer_ms_unittest.cc
+++ b/content/renderer/media/stream/webmediaplayer_ms_unittest.cc
@@ -555,14 +555,13 @@
   blink::WebMediaPlayer::DisplayType DisplayType() const override {
     return blink::WebMediaPlayer::DisplayType::kInline;
   }
+  bool IsInAutoPIP() const override { return false; }
   void ActivateViewportIntersectionMonitoring(bool activate) override {}
   void MediaRemotingStarted(
       const blink::WebString& remote_device_friendly_name) override {}
   void MediaRemotingStopped(
       blink::WebLocalizedString::Name error_msg) override {}
-  void PictureInPictureStarted() override {}
   void PictureInPictureStopped() override {}
-  bool IsInPictureInPictureMode() override { return false; }
 
   // Implementation of cc::VideoFrameProvider::Client
   void StopUsingProvider() override;
diff --git a/media/blink/webmediaplayer_impl.cc b/media/blink/webmediaplayer_impl.cc
index 82d7964..a3fc8994 100644
--- a/media/blink/webmediaplayer_impl.cc
+++ b/media/blink/webmediaplayer_impl.cc
@@ -331,7 +331,10 @@
   client_->MediaRemotingStopped(
       blink::WebLocalizedString::kMediaRemotingStopNoText);
 
-  if (client_->IsInPictureInPictureMode())
+  // If running in Picture-in-Picture but not in auto-pip, notify the player.
+  if (client_->DisplayType() ==
+          WebMediaPlayer::DisplayType::kPictureInPicture &&
+      !client_->IsInAutoPIP())
     ExitPictureInPicture(base::DoNothing());
 
   if (!surface_layer_for_video_enabled_ && video_layer_) {
@@ -415,7 +418,10 @@
   // disabled.
   // The viz::SurfaceId may be updated when the video begins playback or when
   // the size of the video changes.
-  if (client_ && client_->IsInPictureInPictureMode()) {
+  if (client_ &&
+      client_->DisplayType() ==
+          WebMediaPlayer::DisplayType::kPictureInPicture &&
+      !client_->IsInAutoPIP()) {
     delegate_->DidPictureInPictureSurfaceChange(
         delegate_id_, surface_id, pipeline_metadata_.natural_size);
   }
@@ -801,9 +807,6 @@
   delegate_->DidPictureInPictureModeStart(delegate_id_, pip_surface_id_,
                                           pipeline_metadata_.natural_size,
                                           std::move(callback));
-
-  if (client_)
-    client_->PictureInPictureStarted();
 }
 
 void WebMediaPlayerImpl::ExitPictureInPicture(
@@ -821,7 +824,9 @@
 void WebMediaPlayerImpl::RegisterPictureInPictureWindowResizeCallback(
     blink::WebMediaPlayer::PipWindowResizedCallback callback) {
   DCHECK(pip_surface_id_.is_valid());
-  DCHECK(client_->IsInPictureInPictureMode());
+  DCHECK(client_->DisplayType() ==
+             WebMediaPlayer::DisplayType::kPictureInPicture &&
+         !client_->IsInAutoPIP());
 
   delegate_->RegisterPictureInPictureWindowResizeCallback(delegate_id_,
                                                           std::move(callback));
@@ -2967,7 +2972,7 @@
   DCHECK(main_task_runner_->BelongsToCurrentThread());
 
   // Don't optimize Picture-in-Picture players.
-  if (client_->IsInPictureInPictureMode())
+  if (client_->DisplayType() == WebMediaPlayer::DisplayType::kPictureInPicture)
     return false;
 
 #if defined(OS_ANDROID)  // WMPI_CAST
diff --git a/media/blink/webmediaplayer_impl_unittest.cc b/media/blink/webmediaplayer_impl_unittest.cc
index a109241..d8d002d 100644
--- a/media/blink/webmediaplayer_impl_unittest.cc
+++ b/media/blink/webmediaplayer_impl_unittest.cc
@@ -168,12 +168,12 @@
   MOCK_METHOD0(HasNativeControls, bool());
   MOCK_METHOD0(IsAudioElement, bool());
   MOCK_CONST_METHOD0(DisplayType, blink::WebMediaPlayer::DisplayType());
+  MOCK_CONST_METHOD0(IsInAutoPIP, bool());
   MOCK_METHOD1(ActivateViewportIntersectionMonitoring, void(bool));
   MOCK_METHOD1(MediaRemotingStarted, void(const blink::WebString&));
   MOCK_METHOD1(MediaRemotingStopped, void(blink::WebLocalizedString::Name));
   MOCK_METHOD0(PictureInPictureStarted, void());
   MOCK_METHOD0(PictureInPictureStopped, void());
-  MOCK_METHOD0(IsInPictureInPictureMode, bool());
   MOCK_CONST_METHOD0(CouldPlayIfEnoughData, bool());
 
   void set_is_autoplaying_muted(bool value) { is_autoplaying_muted_ = value; }
@@ -1349,7 +1349,9 @@
 TEST_F(WebMediaPlayerImplTest, PictureInPictureTriggerCallback) {
   InitializeWebMediaPlayerImpl();
 
-  EXPECT_CALL(client_, IsInPictureInPictureMode()).WillRepeatedly(Return(true));
+  EXPECT_CALL(client_, DisplayType())
+      .WillRepeatedly(
+          Return(blink::WebMediaPlayer::DisplayType::kPictureInPicture));
   EXPECT_CALL(delegate_,
               DidPictureInPictureSurfaceChange(delegate_.player_id(),
                                                surface_id_, GetNaturalSize()))
@@ -1427,8 +1429,9 @@
     SetDuration(base::TimeDelta::FromSeconds(GetDurationSec()));
 
     if (IsPictureInPictureOn()) {
-      EXPECT_CALL(client_, IsInPictureInPictureMode())
-          .WillRepeatedly(Return(true));
+      EXPECT_CALL(client_, DisplayType())
+          .WillRepeatedly(
+              Return(blink::WebMediaPlayer::DisplayType::kPictureInPicture));
 
       wmpi_->OnSurfaceIdUpdated(surface_id_);
     }
diff --git a/third_party/WebKit/LayoutTests/media/picture-in-picture/picture-in-picture-interstitial.html b/third_party/WebKit/LayoutTests/media/picture-in-picture/picture-in-picture-interstitial.html
index 02d66f5..3889c41 100644
--- a/third_party/WebKit/LayoutTests/media/picture-in-picture/picture-in-picture-interstitial.html
+++ b/third_party/WebKit/LayoutTests/media/picture-in-picture/picture-in-picture-interstitial.html
@@ -19,10 +19,12 @@
 
     checkPictureInPictureInterstitialDoesNotExist(video);
 
-    clickPictureInPictureButton(video, t.step_func_done(() => {
+    video.addEventListener('enterpictureinpicture', t.step_func_done(() => {
       assert_true(isPictureInPictureInterstitialVisible(video),
-          "Interstitial should be visible when button is clicked");
+          "Interstitial should be visible when video enters Picture-in-Picture");
     }));
+
+    clickPictureInPictureButton(video);
   });
 });
 </script>
diff --git a/third_party/blink/public/platform/web_media_player_client.h b/third_party/blink/public/platform/web_media_player_client.h
index 383c411..9db1475 100644
--- a/third_party/blink/public/platform/web_media_player_client.h
+++ b/third_party/blink/public/platform/web_media_player_client.h
@@ -132,15 +132,9 @@
   // to a localized string that explains the reason as user-readable text.
   virtual void MediaRemotingStopped(WebLocalizedString::Name error_msg) = 0;
 
-  // Informs that Picture-in-Picture mode has started for the media element.
-  virtual void PictureInPictureStarted() = 0;
-
   // Informs that Picture-in-Picture mode has stopped for the media element.
   virtual void PictureInPictureStopped() = 0;
 
-  // Returns whether the media element is in Picture-in-Picture mode.
-  virtual bool IsInPictureInPictureMode() = 0;
-
   // Returns whether the media element has native controls. It does not mean
   // that the controls are currently visible.
   virtual bool HasNativeControls() = 0;
@@ -170,6 +164,10 @@
   // WebMediaPlayer::kReadyStateHaveFutureData.
   virtual bool CouldPlayIfEnoughData() const = 0;
 
+  // Returns whether the playback is in auto-pip mode which does not have th
+  // behavior as regular Picture-in-Picture.
+  virtual bool IsInAutoPIP() const = 0;
+
  protected:
   ~WebMediaPlayerClient() = default;
 };
diff --git a/third_party/blink/renderer/core/frame/picture_in_picture_controller.h b/third_party/blink/renderer/core/frame/picture_in_picture_controller.h
index eb11df6..0112287 100644
--- a/third_party/blink/renderer/core/frame/picture_in_picture_controller.h
+++ b/third_party/blink/renderer/core/frame/picture_in_picture_controller.h
@@ -47,6 +47,9 @@
   // Should be called when an element has exited Picture-in-Picture.
   virtual void OnExitedPictureInPicture(ScriptPromiseResolver*) = 0;
 
+  // Returns whether the given element is currently in Picture-in-Picture.
+  virtual bool IsPictureInPictureElement(const Element*) const = 0;
+
   void Trace(blink::Visitor*) override;
 
  protected:
diff --git a/third_party/blink/renderer/core/html/media/html_audio_element.h b/third_party/blink/renderer/core/html/media/html_audio_element.h
index 245427d..569b7b5 100644
--- a/third_party/blink/renderer/core/html/media/html_audio_element.h
+++ b/third_party/blink/renderer/core/html/media/html_audio_element.h
@@ -48,9 +48,7 @@
   // WebMediaPlayerClient implementation.
   void MediaRemotingStarted(
       const WebString& remote_device_friendly_name) override {}
-  void PictureInPictureStarted() override {}
   void PictureInPictureStopped() override {}
-  bool IsInPictureInPictureMode() override { return false; }
   void MediaRemotingStopped(WebLocalizedString::Name error_msg) override {}
 
  private:
diff --git a/third_party/blink/renderer/core/html/media/html_media_element.h b/third_party/blink/renderer/core/html/media/html_media_element.h
index ef680a2..6de68a7 100644
--- a/third_party/blink/renderer/core/html/media/html_media_element.h
+++ b/third_party/blink/renderer/core/html/media/html_media_element.h
@@ -440,6 +440,7 @@
   }
   gfx::ColorSpace TargetColorSpace() override;
   bool WasAutoplayInitiated() override;
+  bool IsInAutoPIP() const override { return false; }
 
   void LoadTimerFired(TimerBase*);
   void ProgressEventTimerFired(TimerBase*);
diff --git a/third_party/blink/renderer/core/html/media/html_video_element.cc b/third_party/blink/renderer/core/html/media/html_video_element.cc
index 5229071..0b654ea 100644
--- a/third_party/blink/renderer/core/html/media/html_video_element.cc
+++ b/third_party/blink/renderer/core/html/media/html_video_element.cc
@@ -259,7 +259,7 @@
 // TODO(zqzhang): this callback could be used to hide native controls instead of
 // using a settings. See `HTMLMediaElement::onMediaControlsEnabledChange`.
 void HTMLVideoElement::OnBecamePersistentVideo(bool value) {
-  is_picture_in_picture_ = value;
+  is_auto_picture_in_picture_ = value;
 
   if (value) {
     // Record the type of video. If it is already fullscreen, it is a video with
@@ -545,7 +545,25 @@
          PictureInPictureController::Status::kEnabled;
 }
 
-void HTMLVideoElement::PictureInPictureStarted() {
+void HTMLVideoElement::PictureInPictureStopped() {
+  PictureInPictureController::From(GetDocument())
+      .OnExitedPictureInPicture(nullptr);
+}
+
+WebMediaPlayer::DisplayType HTMLVideoElement::DisplayType() const {
+  if (is_auto_picture_in_picture_ ||
+      PictureInPictureController::From(GetDocument())
+          .IsPictureInPictureElement(this)) {
+    return WebMediaPlayer::DisplayType::kPictureInPicture;
+  }
+  return HTMLMediaElement::DisplayType();
+}
+
+bool HTMLVideoElement::IsInAutoPIP() const {
+  return is_auto_picture_in_picture_;
+}
+
+void HTMLVideoElement::OnEnteredPictureInPicture() {
   if (!picture_in_picture_interstitial_) {
     picture_in_picture_interstitial_ = new PictureInPictureInterstitial(*this);
     ShadowRoot& shadow_root = EnsureUserAgentShadowRoot();
@@ -554,25 +572,17 @@
     HTMLMediaElement::AssertShadowRootChildren(shadow_root);
   }
   picture_in_picture_interstitial_->Show();
+
+  DCHECK(GetWebMediaPlayer());
+  GetWebMediaPlayer()->OnDisplayTypeChanged(DisplayType());
 }
 
-void HTMLVideoElement::PictureInPictureStopped() {
+void HTMLVideoElement::OnExitedPictureInPicture() {
   if (picture_in_picture_interstitial_)
     picture_in_picture_interstitial_->Hide();
 
-  PictureInPictureController::From(GetDocument())
-      .OnExitedPictureInPicture(nullptr);
-}
-
-bool HTMLVideoElement::IsInPictureInPictureMode() {
-  return picture_in_picture_interstitial_ &&
-         picture_in_picture_interstitial_->IsVisible();
-}
-
-WebMediaPlayer::DisplayType HTMLVideoElement::DisplayType() const {
-  if (is_picture_in_picture_)
-    return WebMediaPlayer::DisplayType::kPictureInPicture;
-  return HTMLMediaElement::DisplayType();
+  if (GetWebMediaPlayer())
+    GetWebMediaPlayer()->OnDisplayTypeChanged(DisplayType());
 }
 
 void HTMLVideoElement::AddedEventListener(
diff --git a/third_party/blink/renderer/core/html/media/html_video_element.h b/third_party/blink/renderer/core/html/media/html_video_element.h
index 92d75fc..4099832 100644
--- a/third_party/blink/renderer/core/html/media/html_video_element.h
+++ b/third_party/blink/renderer/core/html/media/html_video_element.h
@@ -148,11 +148,15 @@
 
   void MediaRemotingStarted(const WebString& remote_device_friendly_name) final;
   bool SupportsPictureInPicture() const final;
-  void PictureInPictureStarted() final;
   void PictureInPictureStopped() final;
-  bool IsInPictureInPictureMode() final;
   void MediaRemotingStopped(WebLocalizedString::Name error_msg) final;
   WebMediaPlayer::DisplayType DisplayType() const final;
+  bool IsInAutoPIP() const final;
+
+  // Used by the PictureInPictureController as callback when the video element
+  // enters or exits Picture-in-Picture state.
+  void OnEnteredPictureInPicture();
+  void OnExitedPictureInPicture();
 
  protected:
   // EventTarget overrides.
@@ -194,12 +198,14 @@
 
   AtomicString default_poster_url_;
 
-  // TODO(mlamouri): merge these later. At the moment, the former is used for
-  // CSS rules used to hide the custom controls and the latter is used to report
-  // the display type. It's unclear whether using the CSS rules also when native
-  // controls are used would or would not have side effects.
+  // Represents whether the video is 'persistent'. It is used for videos with
+  // custom controls that are in auto-pip (Android). This boolean is used by a
+  // CSS rule.
   bool is_persistent_ = false;
-  bool is_picture_in_picture_ = false;
+
+  // Whether the video is currently in auto-pip (Android). It is not similar to
+  // a video being in regular Picture-in-Picture mode.
+  bool is_auto_picture_in_picture_ = false;
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/modules/picture_in_picture/picture_in_picture_controller_impl.cc b/third_party/blink/renderer/modules/picture_in_picture/picture_in_picture_controller_impl.cc
index 9ca00f5..3fc1814 100644
--- a/third_party/blink/renderer/modules/picture_in_picture/picture_in_picture_controller_impl.cc
+++ b/third_party/blink/renderer/modules/picture_in_picture/picture_in_picture_controller_impl.cc
@@ -101,6 +101,8 @@
 
   picture_in_picture_element_ = element;
 
+  picture_in_picture_element_->OnEnteredPictureInPicture();
+
   picture_in_picture_element_->DispatchEvent(
       Event::CreateBubble(EventTypeNames::enterpictureinpicture));
 
@@ -141,6 +143,8 @@
   if (picture_in_picture_element_) {
     HTMLVideoElement* element = picture_in_picture_element_;
     picture_in_picture_element_ = nullptr;
+
+    element->OnExitedPictureInPicture();
     element->DispatchEvent(
         Event::CreateBubble(EventTypeNames::leavepictureinpicture));
   }
@@ -157,6 +161,13 @@
   return scope.AdjustedElement(*picture_in_picture_element_);
 }
 
+bool PictureInPictureControllerImpl::IsPictureInPictureElement(
+    const Element* element) const {
+  if (!element)
+    return false;
+  return element == picture_in_picture_element_;
+}
+
 void PictureInPictureControllerImpl::Trace(blink::Visitor* visitor) {
   visitor->Trace(picture_in_picture_element_);
   visitor->Trace(picture_in_picture_window_);
diff --git a/third_party/blink/renderer/modules/picture_in_picture/picture_in_picture_controller_impl.h b/third_party/blink/renderer/modules/picture_in_picture/picture_in_picture_controller_impl.h
index 3b362bd..94c3d66 100644
--- a/third_party/blink/renderer/modules/picture_in_picture/picture_in_picture_controller_impl.h
+++ b/third_party/blink/renderer/modules/picture_in_picture/picture_in_picture_controller_impl.h
@@ -43,9 +43,6 @@
   // request Picture-in-Picture.
   Status IsDocumentAllowed() const;
 
-  // Implementation of PictureInPictureController.
-  Status IsElementAllowed(const HTMLVideoElement&) const override;
-
   // Enter Picture-in-Picture for a video element and resolve promise.
   void EnterPictureInPicture(HTMLVideoElement*, ScriptPromiseResolver*);
 
@@ -58,12 +55,14 @@
   // Exit Picture-in-Picture for a video element and resolve promise if any.
   void ExitPictureInPicture(HTMLVideoElement*, ScriptPromiseResolver*);
 
-  // Implementation of PictureInPictureController.
-  void OnExitedPictureInPicture(ScriptPromiseResolver*) override;
-
   // Returns element currently in Picture-in-Picture if any. Null otherwise.
   Element* PictureInPictureElement(TreeScope&) const;
 
+  // Implementation of PictureInPictureController.
+  void OnExitedPictureInPicture(ScriptPromiseResolver*) override;
+  Status IsElementAllowed(const HTMLVideoElement&) const override;
+  bool IsPictureInPictureElement(const Element*) const override;
+
   void Trace(blink::Visitor*) override;
 
  private:
