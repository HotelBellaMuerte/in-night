--- a/components/autofill/core/browser/autofill_download_manager.cc	
2018-05-20 06:08:17.000000000 -0400
+++ b/components/autofill/core/browser/autofill_download_manager.cc.new	
2018-05-20 13:20:49.384121377 -0400
@@ -73,7 +73,7 @@
 };
 
 const char kDefaultAutofillServerURL[] =
-    "https://clients1.google.com/tbproxy/af/";
+    "about:blank";
 
 // Returns the base URL for the autofill server.
 GURL GetAutofillServerURL() {
@@ -624,67 +624,6 @@
 }
 
 bool AutofillDownloadManager::StartRequest(FormRequestData request_data) {
-  scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory =
-      driver_->GetURLLoaderFactory();
-  DCHECK(url_loader_factory);
-
-  // Get the URL and method to use for this request.
-  std::string method;
-  GURL request_url;
-  std::tie(request_url, method) =
-      UseApi() ? GetRequestURLAndMethodForApi(request_data)
-               : GetRequestURLAndMethod(request_data);
-
-  auto resource_request = std::make_unique<network::ResourceRequest>();
-  resource_request->url = request_url;
-  resource_request->load_flags =
-      net::LOAD_DO_NOT_SEND_COOKIES | net::LOAD_DO_NOT_SAVE_COOKIES;
-  resource_request->method = method;
-
-  // Add Chrome experiment state to the request headers.
-  variations::AppendVariationHeadersUnknownSignedIn(
-      request_url,
-      driver_->IsIncognito() ? variations::InIncognito::kYes
-                             : variations::InIncognito::kNo,
-      &resource_request->headers);
-
-  // Set headers specific to the API if using it.
-  if (UseApi()) {
-    // Encode response serialized proto in base64 for safety.
-    resource_request->headers.SetHeader(kGoogEncodeResponseIfExecutable,
-                                        "base64");
-    // Put API key in request's header if there is.
-    if (!api_key_.empty())
-      resource_request->headers.SetHeader(kGoogApiKey, api_key_);
-  }
-
-  auto simple_loader = network::SimpleURLLoader::Create(
-      std::move(resource_request),
-      GetNetworkTrafficAnnotation(request_data.request_type));
-
-  // This allows reading the error message within the API response when status
-  // is not 200 (e.g., 400). Otherwise, URL loader will not give any content in
-  // the response when there is a failure, which makes debugging hard.
-  simple_loader->SetAllowHttpErrorResults(true);
-
-  if (method == "POST") {
-    const std::string content_type =
-        UseApi() ? "application/x-protobuf" : "text/proto";
-    // Attach payload data and add data format header.
-    simple_loader->AttachStringForUpload(request_data.payload, content_type);
-  }
-
-  // Transfer ownership of the loader into url_loaders_. Temporarily hang
-  // onto the raw pointer to use it as a key and to kick off the request;
-  // transferring ownership (std::move) invalidates the |simple_loader|
-  // variable.
-  auto* raw_simple_loader = simple_loader.get();
-  url_loaders_.push_back(std::move(simple_loader));
-  raw_simple_loader->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
-      url_loader_factory.get(),
-      base::BindOnce(&AutofillDownloadManager::OnSimpleLoaderComplete,
-                     base::Unretained(this), std::move(--url_loaders_.end()),
-                     std::move(request_data), base::TimeTicks::Now()));
   return true;
 }
 
